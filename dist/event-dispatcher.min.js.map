{"version":3,"file":"event-dispatcher.min.js","sources":["../src/index.ts"],"sourcesContent":["export type EventListener = (object?: any) => void;\n// export type EventListenerRemover = () => void;\n\n/**\n * Parent class for typed EventDispatcher subclasses.\n * See https://github.com/amandaghassaei/event-dispatcher#use\n * for an example of how to subclass EventDispatcherPrototype.\n * @param T - The type of events this object should dispatch.\n */\nexport class EventDispatcherPrototype<T> {\n\t/**\n\t * @private\n\t */\n\tprivate __listeners: { [key: string]: EventListener[] } | undefined;\n\n\t/**\n\t * Add one time event listener for a given event type (unsubscriber is called after first dispatch).\n\t * @param type - The type of the event as a string.\n\t * @param listener - An event listener function.\n\t */\n\tprotected _addOneTimeEventListener(type: T, listener: EventListener) {\n\t\tconst _listener = (object: any) => {\n\t\t\tlistener(object);\n\t\t\tthis._removeEventListener(type, _listener);\n\t\t}\n\t\tthis._addEventListener(type, _listener);\n\t\t// return () => {\n\t\t// \tthis._removeEventListener(type, _listener);\n\t\t// };\n\t}\n\n\t/**\n\t * Add an event listener for a given event type.\n\t * @param type - The type of the event as a string.\n\t * @param listener - An event listener function\n\t */\n\tprotected _addEventListener(type: T, listener: EventListener) {\n\t\tif (!this.__listeners) this.__listeners = {};\n\t\tconst listeners = this.__listeners;\n\t\tif (listeners[type as string] === undefined) {\n\t\t\tlisteners[type as string] = [];\n\t\t}\n\t\t// Add listener only if it hasn't been added already.\n\t\tif (listeners[type as string].indexOf(listener) === -1) {\n\t\t\tlisteners[type as string].push(listener);\n\t\t} else {\n\t\t\tconsole.warn(`Event listener \"${listener.name}\" with value ${listener.toString()} has already been added to object ${this.constructor.name}, ignoring call to _addEventListener().`);\n\t\t}\n\t\t// return () => {\n\t\t// \tthis._removeEventListener(type, listener);\n\t\t// };\n\t}\n\n\t/**\n\t * Remove an event listener for a given event type.\n\t * @param type - The type of the event as a string.\n\t * @param listener - The currently bound event listener function.\n\t */\n\tprotected _removeEventListener(type: T, listener: EventListener) {\n\t\tconst listeners = this.__listeners;\n\t\tif (listeners) {\n\t\t\tconst listenerArray = listeners[type as string];\n\t\t\tif (listenerArray) {\n\t\t\t\tconst index = listenerArray.indexOf(listener);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new Error(`Event listener \"${listener.name}\" with value ${listener.toString()} is not present on object ${this.constructor.name}, ignoring call to _removeEventListener().`);\n\t}\n\n\t/**\n\t * Dispatch an event from this object.\n\t * @param type - The type of the event as a string.\n\t * @param object - An optional object to pass to event listener function.\n\t */\n\tprotected _dispatchEvent(type: T, object?: any) {\n\t\tif (this.__listeners === undefined) return;\n\t\tconst listeners = this.__listeners;\n\t\tlet listenerArray = listeners[type as string];\n\t\tif (listenerArray) {\n\t\t\t// Make a copy in case listeners are removed while iterating.\n\t\t\tlistenerArray = listenerArray.slice(0);\n\t\t\tfor (let i = 0, l = listenerArray.length; i < l; i ++) {\n\t\t\t\tlistenerArray[i](object);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of currently bound listeners for a given event.\n\t * @param type - Event type.\n\t * @returns - The number of currently bound listeners for this event type.\n\t */\n\tgetNumberOfListenersForEvent(type: T) {\n\t\tconst { __listeners } = this;\n\t\tif (!__listeners) return 0;\n\t\tconst typeListeners = __listeners[type as string];\n\t\tif (!typeListeners) return 0;\n\t\treturn typeListeners.length;\n\t}\n\n\t/**\n\t * Dispose all currently bound listeners from this object.\n\t */\n\tdispose() {\n\t\t// Remove all event listeners.\n\t\tthis.__listeners = undefined;\n\t}\n}"],"names":["EventDispatcherPrototype","prototype","_addOneTimeEventListener","type","listener","_this","this","_listener","object","_removeEventListener","_addEventListener","__listeners","listeners","undefined","indexOf","push","console","warn","concat","name","toString","constructor","listenerArray","index","splice","Error","_dispatchEvent","i","l","slice","length","getNumberOfListenersForEvent","typeListeners","dispose"],"mappings":"wPASA,IAAAA,EAAA,WAAA,SAAAA,IAsGC,CAAD,OA3FWA,EAAAC,UAAAC,yBAAV,SAAmCC,EAASC,GAA5C,IASCC,EAAAC,KARMC,EAAY,SAACC,GAClBJ,EAASI,GACTH,EAAKI,qBAAqBN,EAAMI,EACjC,EACAD,KAAKI,kBAAkBP,EAAMI,IAWpBP,EAAAC,UAAAS,kBAAV,SAA4BP,EAASC,GAC/BE,KAAKK,cAAaL,KAAKK,YAAc,IAC1C,IAAMC,EAAYN,KAAKK,iBACWE,IAA9BD,EAAUT,KACbS,EAAUT,GAAkB,KAGwB,IAAjDS,EAAUT,GAAgBW,QAAQV,GACrCQ,EAAUT,GAAgBY,KAAKX,GAE/BY,QAAQC,KAAK,mBAAAC,OAAmBd,EAASe,6BAAoBf,EAASgB,WAAU,sCAAAF,OAAqCZ,KAAKe,YAAYF,KAAI,6CAYlInB,EAAAC,UAAAQ,qBAAV,SAA+BN,EAASC,GACvC,IAAMQ,EAAYN,KAAKK,YACvB,GAAIC,EAAW,CACd,IAAMU,EAAgBV,EAAUT,GAChC,GAAImB,EAAe,CAClB,IAAMC,EAAQD,EAAcR,QAAQV,GACpC,IAAe,IAAXmB,EAEH,YADAD,EAAcE,OAAOD,EAAO,EAG7B,CACD,CACD,MAAM,IAAIE,MAAM,mBAAAP,OAAmBd,EAASe,6BAAoBf,EAASgB,WAAU,8BAAAF,OAA6BZ,KAAKe,YAAYF,KAAI,gDAQ5HnB,EAAAC,UAAAyB,eAAV,SAAyBvB,EAASK,GACjC,QAAyBK,IAArBP,KAAKK,YAAT,CACA,IACIW,EADchB,KAAKK,YACOR,GAC9B,GAAImB,EAGH,IAAK,IAAIK,EAAI,EAAGC,GADhBN,EAAgBA,EAAcO,MAAM,IACFC,OAAQH,EAAIC,EAAGD,IAChDL,EAAcK,GAAGnB,EAPwB,GAiB5CR,EAA4BC,UAAA8B,6BAA5B,SAA6B5B,GACpB,IAAAQ,EAAgBL,KAAIK,YAC5B,IAAKA,EAAa,OAAO,EACzB,IAAMqB,EAAgBrB,EAAYR,GAClC,OAAK6B,EACEA,EAAcF,OADM,GAO5B9B,EAAAC,UAAAgC,QAAA,WAEC3B,KAAKK,iBAAcE,GAEpBb,CAAD"}