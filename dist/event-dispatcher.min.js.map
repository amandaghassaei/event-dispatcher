{"version":3,"file":"event-dispatcher.min.js","sources":["../src/index.ts"],"sourcesContent":["export type EventListener = (object?: any) => void;\n// export type EventListenerRemover = () => void;\n\n/**\n * Parent class for typed EventDispatcher subclasses.\n * See https://github.com/amandaghassaei/event-dispatcher#use\n * for an example of how to subclass EventDispatcherPrototype.\n * @param T - The type of events this object should dispatch.\n */\nexport class EventDispatcherPrototype<T> {\n\t/**\n\t * @private\n\t */\n\tprivate __listeners: { [key: string]: EventListener[] } | undefined;\n\n\t/**\n\t * Add one time event listener for a given event type (unsubscriber is called after first dispatch).\n\t * @param type - The type of the event as a string.\n\t * @param listener - An event listener function.\n\t */\n\tprotected _prototype_addOneTimeEventListener(type: T, listener: EventListener) {\n\t\tconst _listener = (object: any) => {\n\t\t\tlistener(object);\n\t\t\tthis._prototype_removeEventListener(type, _listener);\n\t\t}\n\t\tthis._prototype_addEventListener(type, _listener);\n\t\t// return () => {\n\t\t// \tthis._removeEventListener(type, _listener);\n\t\t// };\n\t}\n\n\t/**\n\t * Add an event listener for a given event type.\n\t * @param type - The type of the event as a string.\n\t * @param listener - An event listener function\n\t */\n\tprotected _prototype_addEventListener(type: T, listener: EventListener) {\n\t\tif (!this.__listeners) this.__listeners = {};\n\t\tconst listeners = this.__listeners;\n\t\tif (listeners[type as string] === undefined) {\n\t\t\tlisteners[type as string] = [];\n\t\t}\n\t\t// Add listener only if it hasn't been added already.\n\t\tif (listeners[type as string].indexOf(listener) === -1) {\n\t\t\tlisteners[type as string].push(listener);\n\t\t} else {\n\t\t\tconsole.warn(`Event listener \"${listener.name}\" with value ${listener.toString()} has already been added to object ${this.constructor.name}, ignoring call to _addEventListener().`);\n\t\t}\n\t\t// return () => {\n\t\t// \tthis._removeEventListener(type, listener);\n\t\t// };\n\t}\n\n\t/**\n\t * Remove an event listener for a given event type.\n\t * @param type - The type of the event as a string.\n\t * @param listener - The currently bound event listener function.\n\t */\n\tprotected _prototype_removeEventListener(type: T, listener: EventListener) {\n\t\tconst listeners = this.__listeners;\n\t\tif (listeners) {\n\t\t\tconst listenerArray = listeners[type as string];\n\t\t\tif (listenerArray) {\n\t\t\t\tconst index = listenerArray.indexOf(listener);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// throw new Error(`Event listener \"${listener.name}\" with value ${listener.toString()} is not present on object ${this.constructor.name}, ignoring call to _removeEventListener().`);\n\t}\n\n\t/**\n\t * Dispatch an event from this object.\n\t * @param type - The type of the event as a string.\n\t * @param object - An optional object to pass to event listener function.\n\t */\n\tprotected _prototype_dispatchEvent(type: T, object?: any) {\n\t\tif (this.__listeners === undefined) return;\n\t\tconst listeners = this.__listeners;\n\t\tlet listenerArray = listeners[type as string];\n\t\tif (listenerArray) {\n\t\t\t// Make a copy in case listeners are removed while iterating.\n\t\t\tlistenerArray = listenerArray.slice(0);\n\t\t\tfor (let i = 0, l = listenerArray.length; i < l; i ++) {\n\t\t\t\tlistenerArray[i](object);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of currently bound listeners for a given event.\n\t * @param type - Event type.\n\t * @returns - The number of currently bound listeners for this event type.\n\t */\n\tgetNumberOfListenersForEvent(type: T) {\n\t\tconst { __listeners } = this;\n\t\tif (!__listeners) return 0;\n\t\tconst typeListeners = __listeners[type as string];\n\t\tif (!typeListeners) return 0;\n\t\treturn typeListeners.length;\n\t}\n\n\t/**\n\t * Dispose all currently bound listeners from this object.\n\t */\n\tdispose() {\n\t\t// Remove all event listeners.\n\t\tthis.__listeners = undefined;\n\t}\n}"],"names":["exports","EventDispatcherPrototype","_prototype_addOneTimeEventListener","type","listener","_listener","object","this","_prototype_removeEventListener","_prototype_addEventListener","__listeners","listeners","undefined","indexOf","push","console","warn","name","toString","constructor","listenerArray","index","splice","_prototype_dispatchEvent","slice","i","l","length","getNumberOfListenersForEvent","typeListeners","dispose"],"mappings":"0LASAA,QAsGCC,yBAtGD,MAWWC,mCAAmCC,EAASC,GACrD,MAAMC,EAAaC,IAClBF,EAASE,GACTC,KAAKC,+BAA+BL,EAAME,EAAU,EAErDE,KAAKE,4BAA4BN,EAAME,EAIvC,CAOSI,4BAA4BN,EAASC,GACzCG,KAAKG,cAAaH,KAAKG,YAAc,IAC1C,MAAMC,EAAYJ,KAAKG,iBACWE,IAA9BD,EAAUR,KACbQ,EAAUR,GAAkB,KAGwB,IAAjDQ,EAAUR,GAAgBU,QAAQT,GACrCO,EAAUR,GAAgBW,KAAKV,GAE/BW,QAAQC,KAAK,mBAAmBZ,EAASa,oBAAoBb,EAASc,+CAA+CX,KAAKY,YAAYF,8CAKvI,CAOST,+BAA+BL,EAASC,GACjD,MAAMO,EAAYJ,KAAKG,YACvB,GAAIC,EAAW,CACd,MAAMS,EAAgBT,EAAUR,GAChC,GAAIiB,EAAe,CAClB,MAAMC,EAAQD,EAAcP,QAAQT,GACpC,IAAe,IAAXiB,EAEH,YADAD,EAAcE,OAAOD,EAAO,EAG7B,CACD,CAED,CAOSE,yBAAyBpB,EAASG,GAC3C,QAAyBM,IAArBL,KAAKG,YAA2B,OAEpC,IAAIU,EADcb,KAAKG,YACOP,GAC9B,GAAIiB,EAAe,CAElBA,EAAgBA,EAAcI,MAAM,GACpC,IAAK,IAAIC,EAAI,EAAGC,EAAIN,EAAcO,OAAQF,EAAIC,EAAGD,IAChDL,EAAcK,GAAGnB,EAElB,CACD,CAODsB,6BAA6BzB,GAC5B,MAAMO,YAAEA,GAAgBH,KACxB,IAAKG,EAAa,OAAO,EACzB,MAAMmB,EAAgBnB,EAAYP,GAClC,OAAK0B,EACEA,EAAcF,OADM,CAE3B,CAKDG,UAECvB,KAAKG,iBAAcE,CACnB"}